# Label Components

## Overview

### Purpose
Use this component to generate label functionality

### When to Use
The Label component is essential for creating accessible and well-structured forms. Use this component when you need to:

- Provide clear, descriptive text labels for form controls and input elements
- Establish proper accessibility relationships between labels and their associated editors
- Create semantic form layouts that work with screen readers and assistive technologies
- Implement consistent labeling patterns across your application forms
- Support click-to-focus behavior where clicking the label focuses the associated editor
- Build forms that comply with WCAG accessibility guidelines and standards
- Handle complex form scenarios with non-native form elements that need proper labeling
- Create responsive form designs with consistent label styling and positioning
- Manage form validation states with visual indicators for required and optional fields
- Support both traditional htmlFor relationships and custom editor reference patterns

### Architecture
**No Coupling**: This is a standalone component that can be used independently. The Label component encapsulates all its functionality within a single, self-contained element that manages label text rendering, accessibility attributes, and editor associations without requiring other components.

## Components

### Label {Standalone Component}
A comprehensive label component that provides enhanced functionality over native HTML label elements with accessibility features and editor integration support.

**Purpose:** Creates accessible, clickable labels for form controls with support for both native and custom editors, validation states, and optional field indicators.

**Interface:**
```typescript
interface LabelProps {
  // Content and Text
  children?: any; // The text or elements that will be rendered inside the label element
  
  // Editor Association
  id?: string; // Represents the id of the label element for ariaLabelledBy references
  editorId?: string; // The id of the associated editor for htmlFor relationship
  editorRef?: any; // React ref to the editor for click-to-focus on non-native elements
  
  // Editor State Integration
  editorValid?: boolean; // Specifies the validity of the editor for styling
  editorDisabled?: boolean; // Specifies if the editor is disabled for consistent styling
  
  // Field Requirements
  optional?: boolean; // If enabled, marks the label as optional with visual indicator
  
  // Styling and Appearance
  style?: React.CSSProperties; // The styles that are applied to the Label
  className?: string; // Sets a class of the Label DOM element
}
```

**Usage Example:**
```tsx
import { Label } from '@progress/kendo-react-labels';
import { TextBox, DropDownList } from '@progress/kendo-react-inputs';

// Basic label with native form element
function BasicLabelExample() {
  return (
    <div>
      <Label editorId="username">Username:</Label>
      <TextBox id="username" />
    </div>
  );
}

// Advanced label with editor reference for custom components
function AdvancedLabelExample() {
  const dropdownRef = React.useRef(null);
  const labelId = 'size-label';
  const editorId = 'size-dropdown';
  
  return (
    <div>
      <Label 
        id={labelId} 
        editorId={editorId} 
        editorRef={dropdownRef}
        optional={true}
      >
        Shirt Size:
      </Label>
      <DropDownList
        ref={dropdownRef}
        id={editorId}
        ariaLabelledBy={labelId}
        data={['Small', 'Medium', 'Large']}
      />
    </div>
  );
}

// Label with validation state
function ValidationLabelExample() {
  const [email, setEmail] = React.useState('');
  const [isValid, setIsValid] = React.useState(true);
  
  const validateEmail = (value) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(value);
  };
  
  const handleChange = (event) => {
    const newValue = event.value;
    setEmail(newValue);
    setIsValid(validateEmail(newValue));
  };
  
  return (
    <div>
      <Label 
        editorId="email" 
        editorValid={isValid}
        className={!isValid ? 'error-label' : ''}
      >
        Email Address:
      </Label>
      <TextBox
        id="email"
        value={email}
        onChange={handleChange}
        className={!isValid ? 'k-invalid' : ''}
      />
      {!isValid && (
        <div className="error-message">Please enter a valid email address</div>
      )}
    </div>
  );
}

// Label for disabled editor
function DisabledLabelExample() {
  const [isDisabled, setIsDisabled] = React.useState(true);
  
  return (
    <div>
      <Label 
        editorId="readonly-field" 
        editorDisabled={isDisabled}
        className={isDisabled ? 'disabled-label' : ''}
      >
        Read-only Field:
      </Label>
      <TextBox
        id="readonly-field"
        value="This field is disabled"
        disabled={isDisabled}
      />
      <button onClick={() => setIsDisabled(!isDisabled)}>
        {isDisabled ? 'Enable' : 'Disable'} Field
      </button>
    </div>
  );
}
```

## Integration Patterns

### Form Layout with Multiple Labels
```tsx
import { Label } from '@progress/kendo-react-labels';
import { TextBox, NumericTextBox, DatePicker } from '@progress/kendo-react-inputs';
import { DropDownList } from '@progress/kendo-react-dropdowns';
import { Button } from '@progress/kendo-react-buttons';

function UserRegistrationForm() {
  const [formData, setFormData] = React.useState({
    firstName: '',
    lastName: '',
    email: '',
    age: null,
    birthDate: null,
    country: null
  });
  
  const [errors, setErrors] = React.useState({});
  
  const countries = ['United States', 'Canada', 'United Kingdom', 'Germany', 'France'];
  
  const updateField = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: null }));
    }
  };
  
  const validateForm = () => {
    const newErrors = {};
    
    if (!formData.firstName.trim()) {
      newErrors.firstName = 'First name is required';
    }
    
    if (!formData.lastName.trim()) {
      newErrors.lastName = 'Last name is required';
    }
    
    if (!formData.email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = 'Please enter a valid email address';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (validateForm()) {
      console.log('Form submitted:', formData);
      // Process form submission
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="registration-form">
      <h2>User Registration</h2>
      
      <div className="form-row">
        <div className="form-field">
          <Label 
            editorId="firstName" 
            editorValid={!errors.firstName}
            className={errors.firstName ? 'error-label' : ''}
          >
            First Name:
          </Label>
          <TextBox
            id="firstName"
            value={formData.firstName}
            onChange={(e) => updateField('firstName', e.value)}
            className={errors.firstName ? 'k-invalid' : ''}
          />
          {errors.firstName && (
            <div className="error-message">{errors.firstName}</div>
          )}
        </div>
        
        <div className="form-field">
          <Label 
            editorId="lastName" 
            editorValid={!errors.lastName}
            className={errors.lastName ? 'error-label' : ''}
          >
            Last Name:
          </Label>
          <TextBox
            id="lastName"
            value={formData.lastName}
            onChange={(e) => updateField('lastName', e.value)}
            className={errors.lastName ? 'k-invalid' : ''}
          />
          {errors.lastName && (
            <div className="error-message">{errors.lastName}</div>
          )}
        </div>
      </div>
      
      <div className="form-field">
        <Label 
          editorId="email" 
          editorValid={!errors.email}
          className={errors.email ? 'error-label' : ''}
        >
          Email Address:
        </Label>
        <TextBox
          id="email"
          value={formData.email}
          onChange={(e) => updateField('email', e.value)}
          className={errors.email ? 'k-invalid' : ''}
          type="email"
        />
        {errors.email && (
          <div className="error-message">{errors.email}</div>
        )}
      </div>
      
      <div className="form-row">
        <div className="form-field">
          <Label editorId="age" optional={true}>
            Age:
          </Label>
          <NumericTextBox
            id="age"
            value={formData.age}
            onChange={(e) => updateField('age', e.value)}
            min={13}
            max={120}
          />
        </div>
        
        <div className="form-field">
          <Label editorId="birthDate" optional={true}>
            Birth Date:
          </Label>
          <DatePicker
            id="birthDate"
            value={formData.birthDate}
            onChange={(e) => updateField('birthDate', e.value)}
          />
        </div>
      </div>
      
      <div className="form-field">
        <Label editorId="country" optional={true}>
          Country:
        </Label>
        <DropDownList
          id="country"
          value={formData.country}
          onChange={(e) => updateField('country', e.value)}
          data={countries}
          placeholder="Select a country..."
        />
      </div>
      
      <div className="form-actions">
        <Button type="submit" primary>Register</Button>
        <Button type="button" onClick={() => setFormData({})}>Clear</Button>
      </div>
    </form>
  );
}
```

### Custom Component Labeling with Editor References
```tsx
import { Label } from '@progress/kendo-react-labels';
import { MultiSelect } from '@progress/kendo-react-dropdowns';
import { ColorPicker } from '@progress/kendo-react-inputs';

function CustomComponentLabeling() {
  const [selectedSkills, setSelectedSkills] = React.useState([]);
  const [favoriteColor, setFavoriteColor] = React.useState('#ff0000');
  
  const skillsRef = React.useRef(null);
  const colorRef = React.useRef(null);
  
  const skills = [
    'JavaScript', 'React', 'TypeScript', 'Node.js', 'CSS', 'HTML',
    'Python', 'Java', 'C#', 'SQL', 'MongoDB', 'GraphQL'
  ];
  
  return (
    <div className="custom-labeling-form">
      <h3>Profile Preferences</h3>
      
      {/* MultiSelect with custom ref handling */}
      <div className="form-field">
        <Label 
          id="skills-label"
          editorId="skills-multiselect"
          editorRef={skillsRef}
          optional={true}
        >
          Technical Skills:
        </Label>
        <MultiSelect
          ref={skillsRef}
          id="skills-multiselect"
          ariaLabelledBy="skills-label"
          value={selectedSkills}
          onChange={(e) => setSelectedSkills(e.value)}
          data={skills}
          placeholder="Select your skills..."
          autoClose={false}
        />
        <div className="field-help">
          Choose the technologies you're proficient in
        </div>
      </div>
      
      {/* ColorPicker with custom ref handling */}
      <div className="form-field">
        <Label 
          id="color-label"
          editorId="color-picker"
          editorRef={colorRef}
          optional={true}
        >
          Favorite Color:
        </Label>
        <ColorPicker
          ref={colorRef}
          id="color-picker"
          ariaLabelledBy="color-label"
          value={favoriteColor}
          onChange={(e) => setFavoriteColor(e.value)}
          format="hex"
        />
        <div className="field-help">
          This will be used for your profile theme
        </div>
      </div>
      
      {/* Display selected values */}
      <div className="preview-section">
        <h4>Selected Preferences:</h4>
        <p><strong>Skills:</strong> {selectedSkills.join(', ') || 'None selected'}</p>
        <p>
          <strong>Color:</strong> 
          <span 
            style={{ 
              backgroundColor: favoriteColor, 
              color: 'white', 
              padding: '2px 8px', 
              marginLeft: '8px',
              borderRadius: '4px'
            }}
          >
            {favoriteColor}
          </span>
        </p>
      </div>
    </div>
  );
}
```

### Dynamic Form with Conditional Labels
```tsx
function DynamicLabelForm() {
  const [userType, setUserType] = React.useState('individual');
  const [formData, setFormData] = React.useState({
    name: '',
    companyName: '',
    taxId: '',
    contactMethod: 'email'
  });
  
  const userTypeRef = React.useRef(null);
  const contactRef = React.useRef(null);
  
  const updateField = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };
  
  const isBusinessUser = userType === 'business';
  
  return (
    <div className="dynamic-form">
      <h3>Account Setup</h3>
      
      {/* User type selection affects subsequent labels */}
      <div className="form-field">
        <Label 
          id="user-type-label"
          editorId="user-type"
          editorRef={userTypeRef}
        >
          Account Type:
        </Label>
        <DropDownList
          ref={userTypeRef}
          id="user-type"
          ariaLabelledBy="user-type-label"
          value={userType}
          onChange={(e) => setUserType(e.value)}
          data={[
            { text: 'Individual', value: 'individual' },
            { text: 'Business', value: 'business' }
          ]}
          textField="text"
          dataItemKey="value"
        />
      </div>
      
      {/* Conditional name field with dynamic label */}
      <div className="form-field">
        <Label editorId="name">
          {isBusinessUser ? 'Business Name:' : 'Full Name:'}
        </Label>
        <TextBox
          id="name"
          value={formData.name}
          onChange={(e) => updateField('name', e.value)}
          placeholder={isBusinessUser ? 'Enter business name' : 'Enter your full name'}
        />
      </div>
      
      {/* Business-specific fields */}
      {isBusinessUser && (
        <>
          <div className="form-field">
            <Label editorId="companyName">
              Legal Company Name:
            </Label>
            <TextBox
              id="companyName"
              value={formData.companyName}
              onChange={(e) => updateField('companyName', e.value)}
              placeholder="Enter legal company name"
            />
          </div>
          
          <div className="form-field">
            <Label editorId="taxId" optional={true}>
              Tax ID / EIN:
            </Label>
            <TextBox
              id="taxId"
              value={formData.taxId}
              onChange={(e) => updateField('taxId', e.value)}
              placeholder="Enter tax identification number"
            />
          </div>
        </>
      )}
      
      {/* Contact method with custom label styling */}
      <div className="form-field">
        <Label 
          id="contact-label"
          editorId="contact-method"
          editorRef={contactRef}
          className="preferred-contact-label"
        >
          Preferred Contact Method:
        </Label>
        <DropDownList
          ref={contactRef}
          id="contact-method"
          ariaLabelledBy="contact-label"
          value={formData.contactMethod}
          onChange={(e) => updateField('contactMethod', e.value)}
          data={[
            { text: 'Email', value: 'email' },
            { text: 'Phone', value: 'phone' },
            { text: 'SMS', value: 'sms' }
          ]}
          textField="text"
          dataItemKey="value"
        />
      </div>
      
      <div className="form-summary">
        <h4>Form Summary:</h4>
        <ul>
          <li>Account Type: {userType === 'business' ? 'Business' : 'Individual'}</li>
          <li>{isBusinessUser ? 'Business' : 'Full'} Name: {formData.name || 'Not provided'}</li>
          {isBusinessUser && (
            <>
              <li>Company Name: {formData.companyName || 'Not provided'}</li>
              <li>Tax ID: {formData.taxId || 'Not provided'}</li>
            </>
          )}
          <li>Contact Method: {formData.contactMethod}</li>
        </ul>
      </div>
    </div>
  );
}
```

### Accessibility-Focused Label Implementation
```tsx
function AccessibleLabelForm() {
  const [formData, setFormData] = React.useState({
    username: '',
    password: '',
    confirmPassword: '',
    newsletter: false
  });
  
  const [errors, setErrors] = React.useState({});
  const [fieldHelp, setFieldHelp] = React.useState({});
  
  // Generate unique IDs for accessibility
  const usernameId = 'username-field';
  const passwordId = 'password-field';
  const confirmPasswordId = 'confirm-password-field';
  const usernameHelpId = 'username-help';
  const passwordHelpId = 'password-help';
  const usernameErrorId = 'username-error';
  const passwordErrorId = 'password-error';
  const confirmPasswordErrorId = 'confirm-password-error';
  
  const updateField = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear errors on change
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: null }));
    }
  };
  
  const validateField = (field, value) => {
    let error = null;
    
    switch (field) {
      case 'username':
        if (!value.trim()) {
          error = 'Username is required';
        } else if (value.length < 3) {
          error = 'Username must be at least 3 characters';
        } else if (!/^[a-zA-Z0-9_]+$/.test(value)) {
          error = 'Username can only contain letters, numbers, and underscores';
        }
        break;
      case 'password':
        if (!value) {
          error = 'Password is required';
        } else if (value.length < 8) {
          error = 'Password must be at least 8 characters';
        } else if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value)) {
          error = 'Password must contain at least one uppercase letter, one lowercase letter, and one number';
        }
        break;
      case 'confirmPassword':
        if (!value) {
          error = 'Please confirm your password';
        } else if (value !== formData.password) {
          error = 'Passwords do not match';
        }
        break;
    }
    
    setErrors(prev => ({ ...prev, [field]: error }));
    return !error;
  };
  
  const handleBlur = (field, value) => {
    validateField(field, value);
  };
  
  return (
    <div className="accessible-form">
      <h2 id="form-title">Create Account</h2>
      <p>All fields marked with * are required.</p>
      
      <form role="form" aria-labelledby="form-title">
        {/* Username field with comprehensive accessibility */}
        <div className="form-field">
          <Label 
            editorId={usernameId}
            editorValid={!errors.username}
            className={errors.username ? 'error-label' : ''}
          >
            Username: *
          </Label>
          <TextBox
            id={usernameId}
            value={formData.username}
            onChange={(e) => updateField('username', e.value)}
            onBlur={(e) => handleBlur('username', e.target.value)}
            className={errors.username ? 'k-invalid' : ''}
            ariaDescribedBy={`${usernameHelpId} ${errors.username ? usernameErrorId : ''}`}
            required
          />
          <div id={usernameHelpId} className="field-help">
            Choose a unique username with 3 or more characters. Use only letters, numbers, and underscores.
          </div>
          {errors.username && (
            <div 
              id={usernameErrorId} 
              className="error-message" 
              role="alert"
              aria-live="polite"
            >
              {errors.username}
            </div>
          )}
        </div>
        
        {/* Password field with security requirements */}
        <div className="form-field">
          <Label 
            editorId={passwordId}
            editorValid={!errors.password}
            className={errors.password ? 'error-label' : ''}
          >
            Password: *
          </Label>
          <TextBox
            id={passwordId}
            type="password"
            value={formData.password}
            onChange={(e) => updateField('password', e.value)}
            onBlur={(e) => handleBlur('password', e.target.value)}
            className={errors.password ? 'k-invalid' : ''}
            ariaDescribedBy={`${passwordHelpId} ${errors.password ? passwordErrorId : ''}`}
            required
          />
          <div id={passwordHelpId} className="field-help">
            Password must be at least 8 characters with uppercase, lowercase, and numeric characters.
          </div>
          {errors.password && (
            <div 
              id={passwordErrorId} 
              className="error-message" 
              role="alert"
              aria-live="polite"
            >
              {errors.password}
            </div>
          )}
        </div>
        
        {/* Confirm password field */}
        <div className="form-field">
          <Label 
            editorId={confirmPasswordId}
            editorValid={!errors.confirmPassword}
            className={errors.confirmPassword ? 'error-label' : ''}
          >
            Confirm Password: *
          </Label>
          <TextBox
            id={confirmPasswordId}
            type="password"
            value={formData.confirmPassword}
            onChange={(e) => updateField('confirmPassword', e.value)}
            onBlur={(e) => handleBlur('confirmPassword', e.target.value)}
            className={errors.confirmPassword ? 'k-invalid' : ''}
            ariaDescribedBy={errors.confirmPassword ? confirmPasswordErrorId : undefined}
            required
          />
          {errors.confirmPassword && (
            <div 
              id={confirmPasswordErrorId} 
              className="error-message" 
              role="alert"
              aria-live="polite"
            >
              {errors.confirmPassword}
            </div>
          )}
        </div>
        
        {/* Optional newsletter subscription */}
        <div className="form-field">
          <Label editorId="newsletter" optional={true}>
            Newsletter Subscription:
          </Label>
          <div className="checkbox-container">
            <input
              type="checkbox"
              id="newsletter"
              checked={formData.newsletter}
              onChange={(e) => updateField('newsletter', e.target.checked)}
            />
            <label htmlFor="newsletter" className="checkbox-label">
              Subscribe to our newsletter for updates and promotions
            </label>
          </div>
        </div>
        
        <div className="form-actions">
          <Button 
            type="submit" 
            primary
            disabled={Object.values(errors).some(error => error)}
          >
            Create Account
          </Button>
        </div>
      </form>
    </div>
  );
}
```

## Component Relationships

### Data Flow
The Label component operates independently and does not manage complex data flow. It primarily renders label text and establishes accessibility relationships with associated editors through htmlFor attributes or aria-labelledby references. The component can reflect editor states (validity, disabled) through visual styling but does not directly control editor behavior.

### Event Handling
- **Click Events**: When a label is clicked, it automatically focuses the associated editor if properly linked via editorId (htmlFor) or editorRef
- **Editor Reference Handling**: For custom components that don't support native htmlFor relationships, the editorRef prop provides programmatic focus capability
- **State Synchronization**: The component can reflect editor validation and disabled states through props for consistent visual feedback

## Best Practices

### Usage Guidelines
- Always provide meaningful label text that clearly describes the purpose of the associated form control
- Use `editorId` prop for native form elements to establish proper htmlFor relationships
- Implement `editorRef` prop for custom components that need click-to-focus behavior
- Apply `optional` prop consistently to distinguish between required and optional fields
- Ensure label text is concise but descriptive enough for users to understand the expected input
- Use `editorValid` and `editorDisabled` props to maintain visual consistency between labels and their editors

### Accessibility
- Ensure every form control has an associated label using either the Label component or aria-label attributes
- Use unique `id` values for labels when using aria-labelledby relationships with custom components
- Implement proper error messaging that is programmatically associated with both labels and editors
- Test with screen readers to verify that label-editor relationships are announced correctly
- Maintain sufficient color contrast between label text and background for visual accessibility
- Consider using `required` indicators in label text rather than relying solely on visual cues

### Performance
- Use stable `editorRef` references to prevent unnecessary re-renders when components update
- Avoid creating inline functions or objects in label props to minimize render cycles
- Consider memoizing label components in forms with many fields to optimize rendering performance
- Use consistent `className` and `style` props rather than dynamically generating them on each render
- Implement proper key props when rendering dynamic lists of labeled form fields

## Common Patterns

### Required Field Indicators
```tsx
function RequiredFieldLabels() {
  const [formData, setFormData] = React.useState({
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    notes: ''
  });
  
  return (
    <form className="required-fields-form">
      <fieldset>
        <legend>Contact Information</legend>
        <p className="form-note">Fields marked with * are required.</p>
        
        {/* Required fields with consistent styling */}
        <div className="form-field">
          <Label editorId="firstName" className="required-label">
            First Name: <span className="required-indicator">*</span>
          </Label>
          <TextBox
            id="firstName"
            value={formData.firstName}
            onChange={(e) => setFormData(prev => ({ ...prev, firstName: e.value }))}
            required
          />
        </div>
        
        <div className="form-field">
          <Label editorId="lastName" className="required-label">
            Last Name: <span className="required-indicator">*</span>
          </Label>
          <TextBox
            id="lastName"
            value={formData.lastName}
            onChange={(e) => setFormData(prev => ({ ...prev, lastName: e.value }))}
            required
          />
        </div>
        
        <div className="form-field">
          <Label editorId="email" className="required-label">
            Email: <span className="required-indicator">*</span>
          </Label>
          <TextBox
            id="email"
            type="email"
            value={formData.email}
            onChange={(e) => setFormData(prev => ({ ...prev, email: e.value }))}
            required
          />
        </div>
        
        {/* Optional fields clearly marked */}
        <div className="form-field">
          <Label editorId="phone" optional={true}>
            Phone Number:
          </Label>
          <TextBox
            id="phone"
            type="tel"
            value={formData.phone}
            onChange={(e) => setFormData(prev => ({ ...prev, phone: e.value }))}
          />
        </div>
        
        <div className="form-field">
          <Label editorId="notes" optional={true}>
            Additional Notes:
          </Label>
          <TextArea
            id="notes"
            value={formData.notes}
            onChange={(e) => setFormData(prev => ({ ...prev, notes: e.value }))}
            rows={3}
          />
        </div>
      </fieldset>
    </form>
  );
}
```

### Responsive Label Layout
```tsx
function ResponsiveLabelLayout() {
  const [formData, setFormData] = React.useState({
    address: '',
    city: '',
    state: '',
    zipCode: '',
    country: ''
  });
  
  return (
    <div className="responsive-label-form">
      <h3>Address Information</h3>
      
      {/* Full-width field */}
      <div className="form-field full-width">
        <Label editorId="address">
          Street Address:
        </Label>
        <TextBox
          id="address"
          value={formData.address}
          onChange={(e) => setFormData(prev => ({ ...prev, address: e.value }))}
          placeholder="Enter your street address"
        />
      </div>
      
      {/* Responsive grid layout */}
      <div className="form-row">
        <div className="form-field half-width">
          <Label editorId="city">
            City:
          </Label>
          <TextBox
            id="city"
            value={formData.city}
            onChange={(e) => setFormData(prev => ({ ...prev, city: e.value }))}
          />
        </div>
        
        <div className="form-field quarter-width">
          <Label editorId="state">
            State:
          </Label>
          <DropDownList
            id="state"
            value={formData.state}
            onChange={(e) => setFormData(prev => ({ ...prev, state: e.value }))}
            data={['CA', 'NY', 'TX', 'FL', 'WA']}
            placeholder="Select..."
          />
        </div>
        
        <div className="form-field quarter-width">
          <Label editorId="zipCode">
            ZIP Code:
          </Label>
          <TextBox
            id="zipCode"
            value={formData.zipCode}
            onChange={(e) => setFormData(prev => ({ ...prev, zipCode: e.value }))}
            maxLength={10}
          />
        </div>
      </div>
      
      <div className="form-field full-width">
        <Label editorId="country">
          Country:
        </Label>
        <DropDownList
          id="country"
          value={formData.country}
          onChange={(e) => setFormData(prev => ({ ...prev, country: e.value }))}
          data={['United States', 'Canada', 'Mexico']}
          placeholder="Select your country"
        />
      </div>
      
      <style jsx>{`
        .responsive-label-form {
          max-width: 600px;
          margin: 0 auto;
        }
        
        .form-row {
          display: flex;
          gap: 1rem;
          flex-wrap: wrap;
        }
        
        .form-field {
          display: flex;
          flex-direction: column;
          margin-bottom: 1rem;
        }
        
        .full-width {
          width: 100%;
        }
        
        .half-width {
          flex: 1;
          min-width: 200px;
        }
        
        .quarter-width {
          flex: 0 0 calc(25% - 0.75rem);
          min-width: 120px;
        }
        
        @media (max-width: 768px) {
          .form-row {
            flex-direction: column;
          }
          
          .quarter-width,
          .half-width {
            width: 100%;
            flex: none;
          }
        }
      `}</style>
    </div>
  );
}
```

### Label with Tooltip Help
```tsx
function LabelWithTooltip() {
  const [formData, setFormData] = React.useState({
    apiKey: '',
    webhookUrl: '',
    retryAttempts: 3
  });
  
  const [tooltipVisible, setTooltipVisible] = React.useState({});
  
  const showTooltip = (field) => {
    setTooltipVisible(prev => ({ ...prev, [field]: true }));
  };
  
  const hideTooltip = (field) => {
    setTooltipVisible(prev => ({ ...prev, [field]: false }));
  };
  
  const tooltipContent = {
    apiKey: 'Your API key is used to authenticate requests. Keep this secure and don\'t share it publicly.',
    webhookUrl: 'The URL where we\'ll send webhook notifications. Must be HTTPS for security.',
    retryAttempts: 'Number of times to retry failed webhook deliveries before giving up.'
  };
  
  return (
    <div className="tooltip-label-form">
      <h3>API Configuration</h3>
      
      <div className="form-field">
        <div className="label-with-help">
          <Label editorId="apiKey">
            API Key:
          </Label>
          <button
            type="button"
            className="help-button"
            onMouseEnter={() => showTooltip('apiKey')}
            onMouseLeave={() => hideTooltip('apiKey')}
            onFocus={() => showTooltip('apiKey')}
            onBlur={() => hideTooltip('apiKey')}
            aria-label="Help for API Key field"
          >
            ?
          </button>
          {tooltipVisible.apiKey && (
            <div className="tooltip" role="tooltip">
              {tooltipContent.apiKey}
            </div>
          )}
        </div>
        <TextBox
          id="apiKey"
          type="password"
          value={formData.apiKey}
          onChange={(e) => setFormData(prev => ({ ...prev, apiKey: e.value }))}
          placeholder="Enter your API key"
        />
      </div>
      
      <div className="form-field">
        <div className="label-with-help">
          <Label editorId="webhookUrl">
            Webhook URL:
          </Label>
          <button
            type="button"
            className="help-button"
            onMouseEnter={() => showTooltip('webhookUrl')}
            onMouseLeave={() => hideTooltip('webhookUrl')}
            onFocus={() => showTooltip('webhookUrl')}
            onBlur={() => hideTooltip('webhookUrl')}
            aria-label="Help for Webhook URL field"
          >
            ?
          </button>
          {tooltipVisible.webhookUrl && (
            <div className="tooltip" role="tooltip">
              {tooltipContent.webhookUrl}
            </div>
          )}
        </div>
        <TextBox
          id="webhookUrl"
          type="url"
          value={formData.webhookUrl}
          onChange={(e) => setFormData(prev => ({ ...prev, webhookUrl: e.value }))}
          placeholder="https://your-domain.com/webhook"
        />
      </div>
      
      <div className="form-field">
        <div className="label-with-help">
          <Label editorId="retryAttempts">
            Retry Attempts:
          </Label>
          <button
            type="button"
            className="help-button"
            onMouseEnter={() => showTooltip('retryAttempts')}
            onMouseLeave={() => hideTooltip('retryAttempts')}
            onFocus={() => showTooltip('retryAttempts')}
            onBlur={() => hideTooltip('retryAttempts')}
            aria-label="Help for Retry Attempts field"
          >
            ?
          </button>
          {tooltipVisible.retryAttempts && (
            <div className="tooltip" role="tooltip">
              {tooltipContent.retryAttempts}
            </div>
          )}
        </div>
        <NumericTextBox
          id="retryAttempts"
          value={formData.retryAttempts}
          onChange={(e) => setFormData(prev => ({ ...prev, retryAttempts: e.value }))}
          min={1}
          max={10}
          step={1}
        />
      </div>
      
      <style jsx>{`
        .label-with-help {
          display: flex;
          align-items: center;
          gap: 0.5rem;
          position: relative;
        }
        
        .help-button {
          width: 20px;
          height: 20px;
          border-radius: 50%;
          border: 1px solid #ccc;
          background: #f5f5f5;
          font-size: 12px;
          font-weight: bold;
          cursor: help;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        
        .help-button:hover,
        .help-button:focus {
          background: #e0e0e0;
          border-color: #999;
        }
        
        .tooltip {
          position: absolute;
          top: 100%;
          left: 0;
          background: #333;
          color: white;
          padding: 8px 12px;
          border-radius: 4px;
          font-size: 14px;
          max-width: 300px;
          z-index: 1000;
          box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .tooltip::before {
          content: '';
          position: absolute;
          bottom: 100%;
          left: 12px;
          border: 6px solid transparent;
          border-bottom-color: #333;
        }
      `}</style>
    </div>
  );
}
```
