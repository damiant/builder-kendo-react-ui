# Fade Component

## Overview

### Purpose
Use this component to generate fade animation functionality

### When to Use
The Fade component is essential for creating smooth, polished user experiences through controlled opacity transitions. Use this component when you need to:

- **Content transitions** - Smoothly animate content appearing or disappearing during state changes, navigation, or conditional rendering
- **Modal and overlay introductions** - Create elegant entrance effects for dialogs, tooltips, popups, and other overlay components
- **Page and section transitions** - Add visual continuity when switching between different views, pages, or content sections
- **Loading state transitions** - Smoothly transition from loading states to content display, or fade out completed operations
- **Interactive feedback** - Provide visual feedback for user actions like hover states, focus changes, or click responses
- **Error and success messaging** - Animate the appearance and disappearance of notifications, alerts, and status messages
- **Image and media loading** - Create smooth transitions when images or videos finish loading to prevent jarring content jumps
- **Dynamic content updates** - Animate content changes in real-time applications, such as live feeds, counters, or status updates
- **Form validation feedback** - Smoothly show or hide validation messages and error states
- **Progressive disclosure** - Gradually reveal additional content or options based on user interaction or system state

### Architecture
**No Coupling**: Fade is a standalone animation component that operates independently without requiring other components. It provides a complete fade animation solution that can wrap any React content and apply smooth opacity transitions with customizable timing and direction controls.

## Components

### Fade

**Purpose:** Provides smooth fade-in and fade-out animations for any React content, offering precise control over animation timing, direction, and behavior to enhance user interface transitions.

**Interface:**
```typescript
interface FadeProps {
  // Content to animate
  children: React.ReactNode; // The content that will receive the fade animation effect
  
  // Animation configuration
  duration?: number; // Animation duration in milliseconds (default: 400)
  direction?: 'in' | 'out'; // Animation direction - fade in or fade out (default: 'in')
  
  // Control options
  disabled?: boolean; // Disables the animation when true, content appears/disappears instantly
  
  // Styling
  className?: string; // Additional CSS classes for custom styling
  style?: React.CSSProperties; // Inline styles applied to the wrapper element
}
```

**Usage Example:**
```tsx
import { Fade } from '@progress/kendo-react-animation';

function BasicFadeExample() {
  const [isVisible, setIsVisible] = useState(true);
  
  return (
    <div>
      <button onClick={() => setIsVisible(!isVisible)}>
        Toggle Content
      </button>
      
      {isVisible && (
        <Fade duration={300} direction="in">
          <div className="content-card">
            <h3>Animated Content</h3>
            <p>This content will fade in smoothly when rendered.</p>
          </div>
        </Fade>
      )}
    </div>
  );
}
```

## Integration Patterns

### Basic Fade In
```tsx
import { Fade } from '@progress/kendo-react-animation';

// Simple fade-in animation for content appearance
function FadeInExample() {
  return (
    <Fade duration={400} direction="in">
      <div className="welcome-message">
        <h2>Welcome to our application!</h2>
        <p>This message fades in smoothly when the component mounts.</p>
      </div>
    </Fade>
  );
}
```

### Conditional Content with Fade
```tsx
import { Fade } from '@progress/kendo-react-animation';

// Fade animation for conditional content rendering
function ConditionalFadeExample() {
  const [showDetails, setShowDetails] = useState(false);
  
  return (
    <div className="card">
      <h3>Product Information</h3>
      <button onClick={() => setShowDetails(!showDetails)}>
        {showDetails ? 'Hide' : 'Show'} Details
      </button>
      
      {showDetails && (
        <Fade duration={250} direction="in">
          <div className="product-details">
            <p>Detailed product information appears here...</p>
            <ul>
              <li>Feature 1</li>
              <li>Feature 2</li>
              <li>Feature 3</li>
            </ul>
          </div>
        </Fade>
      )}
    </div>
  );
}
```

### Fade with Loading States
```tsx
import { Fade } from '@progress/kendo-react-animation';

// Combining fade animation with loading states
function LoadingFadeExample() {
  const [isLoading, setIsLoading] = useState(true);
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetchData().then(result => {
      setData(result);
      setIsLoading(false);
    });
  }, []);
  
  return (
    <div className="data-container">
      {isLoading ? (
        <Fade duration={200}>
          <div className="loading-spinner">Loading...</div>
        </Fade>
      ) : (
        <Fade duration={300} direction="in">
          <div className="data-content">
            <h3>Data Loaded</h3>
            <pre>{JSON.stringify(data, null, 2)}</pre>
          </div>
        </Fade>
      )}
    </div>
  );
}
```

### Sequential Fade Animations
```tsx
import { Fade } from '@progress/kendo-react-animation';

// Creating sequential fade effects for multiple elements
function SequentialFadeExample() {
  const [visibleItems, setVisibleItems] = useState([]);
  
  useEffect(() => {
    const items = ['item1', 'item2', 'item3'];
    items.forEach((item, index) => {
      setTimeout(() => {
        setVisibleItems(prev => [...prev, item]);
      }, index * 200);
    });
  }, []);
  
  return (
    <div className="sequential-container">
      <h2>Sequential Fade-in</h2>
      {['item1', 'item2', 'item3'].map(item => (
        visibleItems.includes(item) && (
          <Fade key={item} duration={400} direction="in">
            <div className="fade-item">
              <h4>{item.charAt(0).toUpperCase() + item.slice(1)}</h4>
              <p>This item fades in after the previous one.</p>
            </div>
          </Fade>
        )
      ))}
    </div>
  );
}
```

### Fade with Form Validation
```tsx
import { Fade } from '@progress/kendo-react-animation';

// Using fade for smooth validation message display
function FormFadeExample() {
  const [email, setEmail] = useState('');
  const [errors, setErrors] = useState({});
  
  const validateEmail = (value) => {
    const newErrors = {};
    if (!value) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(value)) {
      newErrors.email = 'Email format is invalid';
    }
    setErrors(newErrors);
  };
  
  return (
    <form className="fade-form">
      <div className="field-group">
        <label htmlFor="email">Email Address</label>
        <input
          id="email"
          type="email"
          value={email}
          onChange={(e) => {
            setEmail(e.target.value);
            validateEmail(e.target.value);
          }}
          className={errors.email ? 'error' : ''}
        />
        
        {errors.email && (
          <Fade duration={200} direction="in">
            <div className="error-message">
              {errors.email}
            </div>
          </Fade>
        )}
      </div>
      
      <button type="submit" disabled={!!errors.email}>
        Submit
      </button>
    </form>
  );
}
```

### Performance-Optimized Fade
```tsx
import { Fade } from '@progress/kendo-react-animation';

// Using disabled prop for performance optimization
function OptimizedFadeExample() {
  const [prefersReducedMotion] = useReducedMotion(); // Custom hook
  const [showContent, setShowContent] = useState(false);
  
  return (
    <div>
      <button onClick={() => setShowContent(!showContent)}>
        Toggle Content
      </button>
      
      {showContent && (
        <Fade 
          duration={prefersReducedMotion ? 0 : 300}
          disabled={prefersReducedMotion}
          direction="in"
        >
          <div className="accessible-content">
            <h3>Respectful Animation</h3>
            <p>This animation respects user motion preferences.</p>
          </div>
        </Fade>
      )}
    </div>
  );
}
```

## Best Practices

### Usage Guidelines
- **Choose appropriate durations** - Use 200-400ms for most UI transitions; shorter durations (150-250ms) for subtle effects, longer durations (400-600ms) for prominent content changes
- **Respect user preferences** - Always implement reduced motion support by using the `disabled` prop when users prefer reduced motion
- **Coordinate with conditional rendering** - Combine Fade with conditional rendering patterns to create smooth appearance and disappearance effects
- **Avoid excessive animations** - Don't animate every element; reserve fade effects for meaningful content changes that benefit from smooth transitions

### Accessibility
- **Motion sensitivity** - Respect `prefers-reduced-motion` CSS media query by setting `disabled={true}` for users who prefer reduced motion
- **Screen reader compatibility** - Fade animations don't interfere with screen reader navigation; content remains accessible throughout the animation
- **Focus management** - Ensure focus isn't lost during fade transitions; manage focus appropriately when content appears or disappears
- **Semantic content structure** - Maintain proper heading hierarchy and landmark structure within faded content

### Performance
- **Animation efficiency** - Kendo React Fade uses CSS opacity transitions for optimal performance across devices and browsers
- **Conditional animations** - Use the `disabled` prop to skip animations entirely when not needed, reducing computational overhead
- **Avoid layout thrashing** - Fade only affects opacity, preventing layout recalculations that could impact performance
- **Memory considerations** - Combine Fade with proper component unmounting to ensure animated content is properly cleaned up

## Common Patterns

### Pattern 1: Modal/Dialog Introduction
```tsx
// Smooth fade-in for modal content
function ModalWithFade({ isOpen, onClose }) {
  return (
    <Modal open={isOpen} onClose={onClose}>
      <Fade duration={250} direction="in">
        <div className="modal-content">
          <h2>Modal Title</h2>
          <p>Modal content with smooth fade-in animation.</p>
          <button onClick={onClose}>Close</button>
        </div>
      </Fade>
    </Modal>
  );
}
```

### Pattern 2: Status Message Display
```tsx
// Fade animation for temporary status messages
function StatusMessage({ message, type, visible }) {
  return (
    visible && (
      <Fade duration={300} direction="in">
        <div className={`status-message ${type}`}>
          <span className="message-text">{message}</span>
        </div>
      </Fade>
    )
  );
}
```

### Pattern 3: Progressive Content Reveal
```tsx
// Fade in content sections progressively as they become relevant
function ProgressiveReveal() {
  const [currentStep, setCurrentStep] = useState(0);
  const steps = ['Welcome', 'Features', 'Getting Started'];
  
  return (
    <div className="progressive-content">
      {steps.map((step, index) => (
        index <= currentStep && (
          <Fade key={step} duration={400} direction="in">
            <section className="content-step">
              <h3>{step}</h3>
              <p>Content for {step} section...</p>
            </section>
          </Fade>
        )
      ))}
      
      <button 
        onClick={() => setCurrentStep(prev => Math.min(prev + 1, steps.length - 1))}
        disabled={currentStep >= steps.length - 1}
      >
        Next Step
      </button>
    </div>
  );
}
```

### Pattern 4: Image Loading Transitions
```tsx
// Fade in images after they finish loading
function ImageWithFade({ src, alt }) {
  const [isLoaded, setIsLoaded] = useState(false);
  
  return (
    <div className="image-container">
      {!isLoaded && (
        <div className="image-placeholder">Loading...</div>
      )}
      
      {isLoaded && (
        <Fade duration={300} direction="in">
          <img 
            src={src} 
            alt={alt}
            className="loaded-image"
          />
        </Fade>
      )}
      
      <img 
        src={src}
        alt={alt}
        style={{ display: 'none' }}
        onLoad={() => setIsLoaded(true)}
      />
    </div>
  );
}
```
