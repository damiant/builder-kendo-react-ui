# NumericTextBox Component

## Overview

### Purpose
Use this component to generate numeric text input functionality

### When to Use
The NumericTextBox component is ideal for scenarios where users need to enter numeric values with built-in validation, formatting, and increment/decrement controls. Use NumericTextBox when you need:

- **Numeric form fields** - Collecting quantities, prices, percentages, or measurements in forms
- **Value range constraints** - When specific minimum or maximum numeric boundaries are required
- **Decimal precision control** - When you need to control the number of decimal places displayed or allowed
- **Formatted numeric display** - When numbers need to follow specific formatting patterns (currency, percentages, etc.)
- **Spin button controls** - When users benefit from incrementing/decrementing values using built-in spin buttons
- **Accessible numeric input** - When keyboard navigation and screen reader support for numeric values are essential
- **Real-time validation** - When immediate feedback on numeric validity and range constraints is needed
- **Step-based input** - When values should increment/decrement by specific step amounts

### Architecture
**No Coupling**: NumericTextBox is a standalone component that operates independently without requiring other components. It provides a complete numeric input solution with built-in validation, formatting, spin controls, and accessibility features.

## Components

### NumericTextBox

**Purpose:** Provides a comprehensive numeric input control with formatting, validation, spin buttons, and accessibility features for collecting numeric values from users.

**Interface:**
```typescript
interface NumericTextBoxProps {
  // Value and change handling
  value?: number | null; // The current numeric value
  onChange?: (event: NumericTextBoxChangeEvent) => void; // Callback when value changes
  defaultValue?: number | null; // Initial numeric value for uncontrolled usage
  
  // Numeric constraints
  min?: number; // Minimum allowable value
  max?: number; // Maximum allowable value
  step?: number; // Increment/decrement step amount (default: 1)
  
  // Formatting and display
  format?: string; // Number display format (e.g., 'n2', 'c', 'p')
  decimals?: number; // Number of decimal places to display
  placeholder?: string; // Placeholder text when empty
  
  // UI features
  spinners?: boolean; // Enable/disable spin buttons for value adjustment
  disabled?: boolean; // Disable the entire component
  readonly?: boolean; // Make the input read-only
  selectOnFocus?: boolean; // Select all text when input gains focus
  
  // Validation
  required?: boolean; // Mark field as required
  valid?: boolean; // Override validation state
  validationMessage?: string; // Custom validation message
  validate?: boolean; // Enable built-in validation
  
  // Event handlers
  onFocus?: (event: NumericTextBoxFocusEvent) => void; // Callback when input gains focus
  onBlur?: (event: NumericTextBoxBlurEvent) => void; // Callback when input loses focus
  onKeyDown?: (event: React.KeyboardEvent) => void; // Keyboard event handler
  onKeyPress?: (event: React.KeyboardEvent) => void; // Key press event handler
  
  // Accessibility
  id?: string; // Unique identifier
  name?: string; // Form field name
  ariaLabelledBy?: string; // Reference to labeling element
  ariaDescribedBy?: string; // Reference to describing element
  ariaLabel?: string; // Accessible label text
  
  // Styling
  className?: string; // Custom CSS classes
  style?: React.CSSProperties; // Inline styles
  dir?: 'ltr' | 'rtl'; // Text direction for internationalization
  size?: 'small' | 'medium' | 'large'; // Component size variant
  
  // Form integration
  tabIndex?: number; // Tab order position
  autoFocus?: boolean; // Automatically focus on mount
}

interface NumericTextBoxChangeEvent {
  value: number | null; // The new numeric value
  target: NumericTextBox; // Reference to the component instance
  syntheticEvent: React.SyntheticEvent; // Original React event
}

interface NumericTextBoxFocusEvent {
  target: NumericTextBox; // Reference to the component instance
  syntheticEvent: React.FocusEvent; // Original React focus event
}

interface NumericTextBoxBlurEvent {
  target: NumericTextBox; // Reference to the component instance
  syntheticEvent: React.FocusEvent; // Original React blur event
}
```

**Usage Example:**
```tsx
import { NumericTextBox } from '@progress/kendo-react-inputs';
import { useState } from 'react';

function BasicNumericInput() {
  const [quantity, setQuantity] = useState<number | null>(1);

  return (
    <NumericTextBox
      value={quantity}
      onChange={(event) => setQuantity(event.value)}
      min={1}
      max={100}
      format="n0"
      placeholder="Enter quantity..."
      spinners={true}
    />
  );
}
```

## Integration Patterns

### Basic Usage
```tsx
import { NumericTextBox } from '@progress/kendo-react-inputs';

// Simple controlled numeric input
function SimpleExample() {
  const [amount, setAmount] = useState<number | null>(null);

  return (
    <NumericTextBox
      value={amount}
      onChange={(event) => setAmount(event.value)}
    />
  );
}

// Uncontrolled with default value
function UncontrolledExample() {
  return (
    <NumericTextBox
      defaultValue={50}
      onChange={(event) => console.log('Value changed:', event.value)}
    />
  );
}
```

### Currency Input with Formatting
```tsx
import { NumericTextBox } from '@progress/kendo-react-inputs';
import { useState } from 'react';

function CurrencyInput() {
  const [price, setPrice] = useState<number | null>(null);
  const [validationMessage, setValidationMessage] = useState<string>('');

  const handlePriceChange = (event: NumericTextBoxChangeEvent) => {
    const newPrice = event.value;
    setPrice(newPrice);

    // Custom validation: Price must be positive
    if (newPrice !== null && newPrice <= 0) {
      setValidationMessage('Price must be greater than zero');
    } else {
      setValidationMessage('');
    }
  };

  return (
    <NumericTextBox
      value={price}
      onChange={handlePriceChange}
      format="c2" // Currency format with 2 decimal places
      min={0.01}
      max={999999.99}
      decimals={2}
      step={0.01}
      spinners={true}
      placeholder="$0.00"
      validationMessage={validationMessage}
      required
      ariaLabel="Product Price"
    />
  );
}
```

### Percentage Input
```tsx
function PercentageInput() {
  const [discountRate, setDiscountRate] = useState<number | null>(null);

  return (
    <NumericTextBox
      value={discountRate}
      onChange={(event) => setDiscountRate(event.value)}
      format="p2" // Percentage format with 2 decimal places
      min={0}
      max={1} // 0 to 1 for percentage (0% to 100%)
      step={0.01}
      decimals={2}
      spinners={true}
      placeholder="0.00%"
      ariaLabel="Discount Rate"
    />
  );
}
```

### Quantity Selector with Validation
```tsx
function QuantitySelector() {
  const [quantity, setQuantity] = useState<number | null>(1);
  const [errors, setErrors] = useState<string>('');

  const handleQuantityChange = (event: NumericTextBoxChangeEvent) => {
    const newQuantity = event.value;
    setQuantity(newQuantity);

    // Validation logic
    if (newQuantity === null) {
      setErrors('Quantity is required');
    } else if (newQuantity < 1) {
      setErrors('Minimum quantity is 1');
    } else if (newQuantity > 50) {
      setErrors('Maximum quantity is 50');
    } else {
      setErrors('');
    }
  };

  const handleBlur = () => {
    if (quantity === null) {
      setErrors('Quantity is required');
    }
  };

  return (
    <NumericTextBox
      value={quantity}
      onChange={handleQuantityChange}
      onBlur={handleBlur}
      onFocus={() => setErrors('')}
      min={1}
      max={50}
      format="n0" // No decimal places for quantities
      decimals={0}
      step={1}
      spinners={true}
      selectOnFocus={true}
      validationMessage={errors}
      required
      ariaLabel="Item Quantity"
    />
  );
}
```

### Measurement Input with Units
```tsx
function WeightInput() {
  const [weight, setWeight] = useState<number | null>(null);
  const [unit, setUnit] = useState<'kg' | 'lbs'>('kg');

  const getStepAndFormat = () => {
    return unit === 'kg' 
      ? { step: 0.1, format: 'n1', suffix: ' kg' }
      : { step: 0.5, format: 'n1', suffix: ' lbs' };
  };

  const { step, format } = getStepAndFormat();

  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
      <NumericTextBox
        value={weight}
        onChange={(event) => setWeight(event.value)}
        format={format}
        min={0}
        max={unit === 'kg' ? 500 : 1100} // Different max based on unit
        step={step}
        decimals={1}
        spinners={true}
        placeholder={`Enter weight in ${unit}...`}
        ariaLabel={`Weight in ${unit}`}
      />
      <select 
        value={unit} 
        onChange={(e) => setUnit(e.target.value as 'kg' | 'lbs')}
        aria-label="Weight unit"
      >
        <option value="kg">kg</option>
        <option value="lbs">lbs</option>
      </select>
    </div>
  );
}
```

### Form Integration with Range Validation
```tsx
import { NumericTextBox } from '@progress/kendo-react-inputs';
import { Button } from '@progress/kendo-react-buttons';
import { useState } from 'react';

function NumericForm() {
  const [formData, setFormData] = useState({
    minValue: null as number | null,
    maxValue: null as number | null,
    currentValue: null as number | null
  });
  const [errors, setErrors] = useState<{[key: string]: string}>({});

  const validateForm = () => {
    const newErrors: {[key: string]: string} = {};
    
    if (formData.minValue === null) {
      newErrors.minValue = 'Minimum value is required';
    }
    
    if (formData.maxValue === null) {
      newErrors.maxValue = 'Maximum value is required';
    }
    
    if (formData.currentValue === null) {
      newErrors.currentValue = 'Current value is required';
    }
    
    if (formData.minValue !== null && formData.maxValue !== null && formData.minValue >= formData.maxValue) {
      newErrors.maxValue = 'Maximum must be greater than minimum';
    }
    
    if (formData.currentValue !== null && formData.minValue !== null && formData.currentValue < formData.minValue) {
      newErrors.currentValue = 'Current value must be at least the minimum';
    }
    
    if (formData.currentValue !== null && formData.maxValue !== null && formData.currentValue > formData.maxValue) {
      newErrors.currentValue = 'Current value must not exceed the maximum';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (event: React.FormEvent) => {
    event.preventDefault();
    if (validateForm()) {
      console.log('Form submitted:', formData);
    }
  };

  return (
    <form onSubmit={handleSubmit} style={{ display: 'flex', flexDirection: 'column', gap: '15px', maxWidth: '300px' }}>
      <div>
        <label htmlFor="min-value">Minimum Value:</label>
        <NumericTextBox
          id="min-value"
          name="minValue"
          value={formData.minValue}
          onChange={(event) => {
            setFormData(prev => ({ ...prev, minValue: event.value }));
            setErrors(prev => ({ ...prev, minValue: '' }));
          }}
          format="n2"
          decimals={2}
          step={0.01}
          spinners={true}
          validationMessage={errors.minValue}
          required
        />
      </div>
      
      <div>
        <label htmlFor="max-value">Maximum Value:</label>
        <NumericTextBox
          id="max-value"
          name="maxValue"
          value={formData.maxValue}
          onChange={(event) => {
            setFormData(prev => ({ ...prev, maxValue: event.value }));
            setErrors(prev => ({ ...prev, maxValue: '' }));
          }}
          format="n2"
          decimals={2}
          step={0.01}
          min={formData.minValue || undefined}
          spinners={true}
          validationMessage={errors.maxValue}
          required
        />
      </div>
      
      <div>
        <label htmlFor="current-value">Current Value:</label>
        <NumericTextBox
          id="current-value"
          name="currentValue"
          value={formData.currentValue}
          onChange={(event) => {
            setFormData(prev => ({ ...prev, currentValue: event.value }));
            setErrors(prev => ({ ...prev, currentValue: '' }));
          }}
          format="n2"
          decimals={2}
          step={0.01}
          min={formData.minValue || undefined}
          max={formData.maxValue || undefined}
          spinners={true}
          validationMessage={errors.currentValue}
          required
        />
      </div>
      
      <Button type="submit" primary>Submit</Button>
    </form>
  );
}
```

## Best Practices

### Usage Guidelines
- **Always handle null values** - NumericTextBox can have null values, so ensure your application logic accounts for this possibility
- **Set appropriate constraints** - Use `min`, `max`, and `step` props to define reasonable numeric ranges and increments for your use case
- **Choose appropriate formatting** - Use the `format` prop to match user expectations (currency for prices, percentages for rates, etc.)
- **Provide clear validation** - Combine built-in validation with custom validation logic for comprehensive error handling
- **Control decimal precision** - Use the `decimals` prop to control display precision and prevent floating-point calculation issues

### Accessibility
- **Semantic labeling** - Always provide accessible labels using the `ariaLabel` prop or associate with a label element using `ariaLabelledBy`
- **Keyboard navigation** - NumericTextBox supports full keyboard navigation including arrow keys for value adjustment when spinners are enabled
- **Screen reader support** - The component announces value changes and validation messages to screen readers
- **Focus management** - Use `onFocus` and `onBlur` events to manage validation state and provide user feedback
- **Required field indication** - Use the `required` prop and provide clear validation messages for mandatory fields

### Performance
- **Controlled vs Uncontrolled** - Use controlled components (with `value` and `onChange`) for form state management, uncontrolled (with `defaultValue`) for simple cases
- **Validation optimization** - Implement validation logic efficiently, avoiding complex calculations on every change event
- **Event handler optimization** - Use useCallback hooks for event handlers in React function components to prevent unnecessary re-renders
- **Format string caching** - Reuse format strings rather than creating new ones on each render

## Common Patterns

### Pattern 1: Price Input with Currency Formatting
```tsx
function PriceInput({ value, onChange, currency = 'USD', required = false }) {
  const formatString = currency === 'USD' ? 'c2' : 'n2';
  const currencySymbol = currency === 'USD' ? '$' : '€';
  
  return (
    <NumericTextBox
      value={value}
      onChange={onChange}
      format={formatString}
      min={0}
      max={999999.99}
      decimals={2}
      step={0.01}
      spinners={true}
      placeholder={`${currencySymbol}0.00`}
      required={required}
      ariaLabel={`Price in ${currency}`}
      validationMessage={
        value !== null && value < 0 ? 'Price must be positive' : ''
      }
    />
  );
}
```

### Pattern 2: Quantity Selector with Stock Validation
```tsx
function QuantitySelector({ maxStock, value, onChange }) {
  const [error, setError] = useState<string>('');
  
  const handleChange = (event: NumericTextBoxChangeEvent) => {
    const newValue = event.value;
    onChange(event);
    
    if (newValue !== null && newValue > maxStock) {
      setError(`Only ${maxStock} items available in stock`);
    } else {
      setError('');
    }
  };
  
  return (
    <NumericTextBox
      value={value}
      onChange={handleChange}
      min={1}
      max={maxStock}
      format="n0"
      decimals={0}
      step={1}
      spinners={true}
      validationMessage={error}
      ariaLabel="Quantity to purchase"
      selectOnFocus={true}
    />
  );
}
```

### Pattern 3: Percentage Input with Visual Feedback
```tsx
function PercentageSlider({ value, onChange, label }) {
  const [displayValue, setDisplayValue] = useState<number | null>(value);
  
  const handleChange = (event: NumericTextBoxChangeEvent) => {
    const newValue = event.value;
    setDisplayValue(newValue);
    onChange(event);
  };
  
  const getPercentageColor = (percentage: number | null) => {
    if (percentage === null) return '#ccc';
    if (percentage < 25) return '#ff4444';
    if (percentage < 75) return '#ffaa00';
    return '#44ff44';
  };
  
  return (
    <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>
      <label style={{ fontWeight: 'bold' }}>{label}</label>
      <NumericTextBox
        value={displayValue}
        onChange={handleChange}
        format="n1"
        min={0}
        max={100}
        decimals={1}
        step={0.1}
        spinners={true}
        ariaLabel={label}
      />
      <div 
        style={{ 
          height: '4px', 
          backgroundColor: '#eee', 
          borderRadius: '2px',
          overflow: 'hidden'
        }}
      >
        <div 
          style={{ 
            height: '100%',
            width: `${displayValue || 0}%`,
            backgroundColor: getPercentageColor(displayValue),
            transition: 'all 0.3s ease'
          }}
        />
      </div>
    </div>
  );
}
```

### Pattern 4: Temperature Converter
```tsx
function TemperatureConverter() {
  const [celsius, setCelsius] = useState<number | null>(null);
  const [fahrenheit, setFahrenheit] = useState<number | null>(null);
  
  const handleCelsiusChange = (event: NumericTextBoxChangeEvent) => {
    const c = event.value;
    setCelsius(c);
    setFahrenheit(c !== null ? (c * 9/5) + 32 : null);
  };
  
  const handleFahrenheitChange = (event: NumericTextBoxChangeEvent) => {
    const f = event.value;
    setFahrenheit(f);
    setCelsius(f !== null ? (f - 32) * 5/9 : null);
  };
  
  return (
    <div style={{ display: 'flex', gap: '20px', alignItems: 'center' }}>
      <div>
        <label>Celsius:</label>
        <NumericTextBox
          value={celsius}
          onChange={handleCelsiusChange}
          format="n1"
          decimals={1}
          step={0.1}
          spinners={true}
          ariaLabel="Temperature in Celsius"
        />
      </div>
      
      <span style={{ fontSize: '18px' }}>⇄</span>
      
      <div>
        <label>Fahrenheit:</label>
        <NumericTextBox
          value={fahrenheit}
          onChange={handleFahrenheitChange}
          format="n1"
          decimals={1}
          step={0.1}
          spinners={true}
          ariaLabel="Temperature in Fahrenheit"
        />
      </div>
    </div>
  );
}
```
